<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Basis-splines: Basis-splines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Basis-splines
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Basis-splines </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2basis-splines_2basis-splines_2README"></a> This project includes a C++ library with Python bindings implementing multi-dimensional polynomial splines in basis form and operations to form new splines that represent the derivative, integral, sum, and product of splines. Among other things, polynomial splines are relevant for computer graphics and to solve semi-infinite programs resulting from optimal control problems. For example <a href="https://github.com/meco-group/omg-tools">omg-tools</a> provides a python framework for the formulation and solution of such problems. This project provides a performant C++ implementation of relevant spline operations in this context.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Installation</h1>
<p>The library can be integrated in a C++ and a Python project.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Build from source</h2>
<p>Building the project including the documentation (Doxygen 1.14.0), examples and tests is tested under Ubuntu 22.04 with g++13 and CMake 4.1.0. To build the project, clone the repository and run the following commands:</p>
<div class="fragment"><div class="line">cmake -B build</div>
<div class="line">cmake --build build</div>
</div><!-- fragment --><p>After project build the tests can be run with</p>
<div class="fragment"><div class="line">ctest --test-dir build</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
Integrate in CMake project</h2>
<p>If you desire an integration in a CMake project you may utilize the <a href="https://cmake.org/cmake/help/v4.1/module/FetchContent.html">FetchContent</a> module.</p>
<div class="fragment"><div class="line">FetchContent_Declare(</div>
<div class="line">  basisSplines</div>
<div class="line">  GIT_REPOSITORY https://github.com/phdorp/basis-splines.git</div>
<div class="line">)</div>
<div class="line">set(BUILD_TEST OFF)</div>
<div class="line">set(BUILD_EXAMPLES OFF)</div>
<div class="line">set(BUILD_DOCS OFF)</div>
<div class="line">FetchContent_MakeAvailable(basisSplines)</div>
<div class="line">link_libraries(basisSplines)</div>
</div><!-- fragment --><p>Otherwise, you can directly include the header files in your project.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Build Python bindings</h2>
<p>The Python package <em>basisSplines</em> is build locally by invoking</p>
<div class="fragment"><div class="line">pip install .</div>
</div><!-- fragment --><p>The stubs that document the python bindings are generated by installing the package twice:</p>
<div class="fragment"><div class="line">source setup.bash</div>
<div class="line">pip install .[STUBS]</div>
<div class="line">python $PATH_PYBINDS/basisSplines/buildStubs.py</div>
<div class="line">pip install .</div>
</div><!-- fragment --><p>Additional dependencies for running the Python examples are installed with</p>
<div class="fragment"><div class="line">pip install .[EXAMPLES]</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Install from PyPI</h2>
<p>The Python package <em>basisSplines</em> is also available on <a href="https://pypi.org/project/basis-splines/">PyPI</a> and installed with</p>
<div class="fragment"><div class="line">pip install basis-splines</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Errors encountered during package build</h2>
<h3><a class="anchor" id="autotoc_md7"></a>
Incompatible compiler</h3>
<p>If the build fails due to a compiler not supporting C++20, specify the compiler to use, e.g., <code>g++-13</code>:</p>
<div class="fragment"><div class="line">CXX=g++-13 pip install .</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
GLIBCXX not found</h3>
<p>When installing the package to a conda environment you might encounter an error reporting missing <code>GLIBCXX_x.x.xx</code> library. The error can be resolved by installing the gnu compiler to the conda environment:</p>
<div class="fragment"><div class="line">conda install -c conda-forge gcc</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
Examples</h1>
<p>The examples showcase the library's functionality and require either a Build from source or a Build Python bindings. Run a <a href="https://github.com/phdorp/basis-splines/tree/16-python-bindings/examples/cpp">C++ example</a> [EXAMPLE_NAME] with</p>
<div class="fragment"><div class="line">source setup.bash</div>
<div class="line">./examples/cpp/launch.bash [EXAMPLE_NAME]</div>
</div><!-- fragment --><p>Run all <a href="https://github.com/phdorp/basis-splines/tree/16-python-bindings/examples/cpp">C++ examples</a> without interaction with</p>
<div class="fragment"><div class="line">source setup.bash</div>
<div class="line">echo | ./examples/cpp/launch.bash -a</div>
</div><!-- fragment --><p>The examples rely on <a href="https://github.com/alandefreitas/matplotplusplus">Matplot++</a> for plotting, so make sure to have <a href="http://www.gnuplot.info/">gnuplot</a> installed.</p>
<p>The equivalent <a href="https://github.com/phdorp/basis-splines/tree/16-python-bindings/examples/python">Python examples</a> are invoked with</p>
<div class="fragment"><div class="line">python examples/python/[EXAMPLE_NAME].py</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
Basis functions</h2>
<p>Basis splines are determine recursively on the knots</p>
<p class="formulaDsp">
\begin{aligned}
\mathbf{k}=\begin{bmatrix}\underbrace{\begin{matrix}\kappa_1&amp;\kappa_1&amp;\ldots&amp;\kappa_1\end{matrix}}_{m_1}&amp;\underbrace{\begin{matrix}\kappa_2&amp;\kappa_2&amp;\ldots&amp;\kappa_2\end{matrix}}_{m_2}&amp;\ldots&amp;\kappa_{\breve{{k}}}&amp;\kappa_{\breve{{k}}}\end{bmatrix}.
\end{aligned}
</p>
<p>The knots are composed of the repeated breakpoints \(\kappa_i&lt;\kappa_{i+1}\), \(i=1,2,\ldots,\breve{{\kappa}}\). The multiplicity \(m_i=\rho-\omega_i\) of the \(i\)-th breakpoint determines the spline's order of continuity \(\omega_i\). The recursion's base case is the order \(\rho=1\), considering \(n=1,2,\ldots,\breve{{k}}-1\) knot intervals [1, Ch. IX eq. (11)]</p>
<p class="formulaDsp">
\begin{aligned}
b_{n,1,\mathbf{k}} =
    \begin{cases}
        1 &amp; \text{if } k_n \leq t &lt; k_{n+1}, \\
        0 &amp; \text{otherwise.}
    \end{cases}
\end{aligned}
</p>
<p>Higher orders \(\rho&gt;1\) are determined from lower orders, resulting in truncated power functions with \(l=1,2,\ldots,\breve{{k}}-\rho\) [1, B-spline Prop. (i)]</p>
<p class="formulaDsp">
\begin{aligned}
b_{l,\rho,\mathbf{k}}(x)=\frac{t-k_l}{k_{l+\rho-1}-k_l}b_{l,\rho,\mathbf{k}}(x)+\frac{k_{l+\rho}-t}{k_{l+\rho}-k_{l+1}}b_{l+1,\rho,\mathbf{k}}(x).
\end{aligned}
</p>
<div class="image">
<img src="basis.jpg" alt=""/>
<div class="caption">
Basis spline basis functions</div></div>
    <p>The exemplary B-splines of order 3 with 3 breakpoints are found under <em>examples/basis.cpp</em>.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Spline functions</h2>
<p>Splines in basis form are a linear combination of basis functions weighted with the coefficients \(c_n\) for \(n=0,1,\ldots,\breve{{c}}-1\) [1, Def. (51)]:</p>
<p class="formulaDsp">
\begin{aligned}
s(x)=\sum_{n=0}^{\breve{{c}}-1}c_nb_{n,\rho,\mathbf{k}}(x).
\end{aligned}
</p>
<p>The coefficients form a convex hull that contains the spline's graph.</p>
<div class="image">
<img src="spline2d_allDims.jpg" alt=""/>
<div class="caption">
2-dimensional spline in basis form with convex hull</div></div>
    <p>The example in <em>examples/spline2d.cpp</em> shows 2 splines of order 3 and 4 breakpoints.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Derivative</h2>
<p>The spline derivative \(\dot{s}(x)=\frac{\mathrm{d}}{\mathrm{d}t}s(x)\) has reduced order and continuity. The derivative coefficients are determined from the original coefficients \(c_n\) [1, B-spline Prop. (viii)]:</p>
<p class="formulaDsp">
\begin{aligned}
\dot{s}(x)=\frac{\mathrm{d}}{\mathrm{d}t}\sum_{n=0}^{\breve{{c}}-1}c_nb_{n,\rho,\mathbf{k}}(x)=(\rho-1)\sum_{n=1}^{\breve{{c}}-1}\frac{c_n-c_{n-1}}{k_n-k_{n-1}}b_{n,\rho-1,\mathbf{k}}(x).
\end{aligned}
</p>
<p>Thus, the derivative is the result of a linear transformation of the coefficients \(\dot{s}(x)=\left(\mathbf{T}_{\dot{\mathbf{b}}}^{\mathbf{b}}\mathbf{c}\right)^\intercal b_{n,\rho-1,\mathbf{k}}(x)\):</p>
<p class="formulaDsp">
\begin{aligned}
\mathbf{T}_{\dot{\mathbf{b}}}^{\mathbf{b}}=(\rho-1)
\begin{pmatrix}
\frac{1}{k_1-k_\rho}&amp;\frac{1}{k_\rho-k_1}&amp;0&amp;\ldots&amp;0&amp;0\\
0&amp;\frac{1}{k_2-k_\rho}&amp;\frac{1}{k_\rho-k_2}&amp;0&amp;\ldots&amp;0\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;0&amp;\ldots&amp;\frac{1}{k_{\breve{{k}}-1}-k_{\breve{{c}}}}&amp;\frac{1}{k_{\breve{{c}}}-k_{\breve{{k}}-1}}\\
\end{pmatrix}.
\end{aligned}
</p>
<div class="image">
<img src="splineDeriv.jpg" alt=""/>
<div class="caption">
Spline derivative</div></div>
    <p>The example for differentiating a spline of order 3 is found under <em>examples/splineDeriv.cpp</em>. The file <em>examples/splineDerivExplicit.cpp</em> shows the application of the transformation matrix.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Integral</h2>
<p>The spline integral \(s_\mathrm{I}(x)=\int_{\kappa_0}^t s(\tau)\mathrm{d}\tau\) has increased order and continuity. The transformation to the integral coefficients \(\mathbf{c}_{\mathrm{I}}\) is derived from the derivative definition and yields [1, Ch. X eq. (31)]:</p>
<p class="formulaDsp">
\begin{aligned}
c_{{n+1},\mathrm{I}}=c_{n,\mathrm{I}}+\frac{1}{\rho}(k_{n+\rho}-k_n)c_n
\end{aligned}
</p>
<p>Assuming an initial condition \(c_{0,\mathrm{I}}=0\), the spline integral is also determined by a linear transformation of the coefficients \(s_\mathrm{I}(x)=\left(\mathbf{T}_{\mathbf{b}_\mathrm{I}}^{\mathbf{b}}\mathbf{c}\right)^\intercal b_{n,\rho+1,\mathbf{k}}(x)\) with</p>
<p class="formulaDsp">
\begin{aligned}
\mathbf{T}_{\mathbf{b}_\mathrm{I}}^{\mathbf{b}}=
\begin{pmatrix}
0&amp;0&amp;0&amp;\ldots&amp;0\\
k_\rho-k_0&amp;0&amp;0&amp;\ldots&amp;0\\
k_\rho-k_0&amp;k_{\rho+1}-k_1&amp;0&amp;\ldots&amp;0\\
\vdots&amp;\vdots&amp;\ldots&amp;\ddots&amp;\vdots\\
k_\rho-k_0&amp;k_{\rho+1}-k_1&amp;k_{\rho+2}-k_2&amp;\ldots&amp;k_{\breve{{k}}-1}-k_{\breve{{c}}-1}\\
\end{pmatrix}.
\end{aligned}
</p>
<div class="image">
<img src="splineInteg.jpg" alt=""/>
<div class="caption">
Spline integral</div></div>
    <p>The example for integrating a spline of order 3 is found under <em>examples/splineInteg.cpp</em>. The file <em>examples/splineIntegExplicit.cpp</em> shows the application of the transformation matrix.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Sum and product</h2>
<p>The sum and product of two splines \(s_\square(x)\) and \(s_\triangle(x)\) are exactly described by another spline. The coefficients of the sum \(s_+(x)=s_\square(x)+s_\triangle(x)\) and the product \(s_\times(x)=s_\square(x)\cdot s_\triangle(x)\) are described implicitly by an interpolation:</p>
<p class="formulaDsp">
\begin{aligned}
s_+(\tau_{{j,+}})&amp;=s_\square(\tau_{{j,+}})+s_\triangle(\tau_{{j,+}}),&amp;j=0,1,\ldots,\breve{{c}}_+-1,\\
s_\times(\tau_{{i,\times}})&amp;=s_\square(\tau_{{i,\times}})\cdot s_\triangle(\tau_{{i,\times}}),&amp;i=0,1,\ldots,\breve{{c}}_\times-1.\\
\end{aligned}
</p>
<div class="image">
<img src="splineSum.jpg" alt=""/>
<div class="caption">
Two splines and their sum representation</div></div>
    <div class="image">
<img src="splineProd.jpg" alt=""/>
<div class="caption">
Two splines and their product representation</div></div>
    <p>The coefficients are also determined explicitly with two transformation matrices \(\mathbf{T}_{\mathbf{b}_+}^{\mathbf{b}_{\square}}\) and \(\mathbf{T}_{\mathbf{b}_+}^{\mathbf{b}_\triangle}\) in the sum case, and a single matrix in the product case \(\mathbf{T}_{\mathbf{b}_\times}^{\mathbf{b}_{\square}\odot\mathbf{b}_{\triangle}}\) <a href="(#2)">[2, Property 2 and 3]</a>:</p>
<p class="formulaDsp">
\begin{aligned}
\mathbf{c}_+&amp;=\mathbf{T}_{\mathbf{b}_+}^{\mathbf{b}_{\square}}\mathbf{c}_\square+\mathbf{T}_{\mathbf{b}_+}^{\mathbf{b}_\triangle}\mathbf{c}_\triangle,\\
\mathbf{c}_\times&amp;=\mathbf{T}_{\mathbf{b}_\times}^{\mathbf{b}_{\square}\odot\mathbf{b}_{\triangle}}\left(\mathbf{c}_\square\otimes\mathbf{c}_\triangle\right).
\end{aligned}
</p>
<p>Examples for the sum and product of splines are found under <em>examples/splineSum.cpp</em> and <em>examples/splineProd.cpp</em>. The usage of the transformation matrices is shown in <em>examples/splineSumExpl.cpp</em> and <em>examples/splineProdExpl.cpp</em>.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Convex hull reduction</h2>
<p>The spline function is enclosed by its convex hull so the hull keeps a certain distance to the spline. The formulation of constraints depending on the spline coefficients results therefore in a conservative solution. The solution accuracy is improved by reducing the distance between hull and spline. Two methods are available to reduce the distance: knot insertion and order elevation.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Knot insertion</h3>
<p>The knot insertion creates a new spline basis \(\mathbf{b}_{\rho,\mathbf{k}_\mathrm{in}}(x)\) with a new knot sequence \(\mathbf{k}_\mathrm{in}\) by inserting additional knots to the original knot sequence \(\mathbf{k}\) such that \(\{k_i\}_{i=1,2,\ldots,\breve{k}}\subset\{k_{j,\mathrm{in}}\}_{j=1,2,\ldots,\breve{k}_{\mathrm{in}}}\) while the first \(\mathbf{k}_{1,\mathrm{in}}=\mathbf{k}_{1}\) and the last \(\mathbf{k}_{\breve{{k}}_\mathrm{in},\mathrm{in}}=\mathbf{k}_{\breve{{k}}}\) breakpoints coincide. Thus, \(\mathbf{k}_\mathrm{in}\) is a refinement of \(\mathbf{k}\) such that the splines resulting from \(\mathbf{b}_{\rho,\mathbf{k}}(x)\) are among the possible splines resulting from \(\mathbf{b}_{\rho,\mathbf{k}_\mathrm{in}}(x)\) <a href="(#1)">[1, B-spline Prop. (xi)]</a>:</p>
<p class="formulaDsp">
\begin{aligned}
s(x)&amp;=\sum_{n=1}^{\breve{{c}}}c_nb_{n,\rho,\mathbf{k}}(x),\\
=s_\mathrm{in}(x)&amp;=\sum_{n=1}^{\breve{{c}}_\mathrm{in}}c_{n,\mathrm{in}}b_{n,\rho,\mathbf{k}_\mathrm{in}}(x).
\end{aligned}
</p>
<p>In addition, the distance between the coefficients \(\mathbf{c}_\mathrm{in}\) and \(s_\mathrm{in}(x)\) is smaller than the distance between the coefficients \(\mathbf{c}\) and \(s(x)\).</p>
<div class="image">
<img src="splineKnotInsertion.jpg" alt=""/>
<div class="caption">
Spline function and equivalent spline with refined knot sequence</div></div>
    <p>The example <em>examples/splineKnotInsertion.cpp</em> demonstrates the insertion of 4 additional knots, introducing 2 new breakpoints at 0.3 and 0.4 to a spline of order 3. The addition of each knot introduces a new coefficient for a locally more accurate spline approximation with the control polygon.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Order elevation</h3>
<p>The order elevation creates a new spline basis \(\mathbf{b}_{\hat{\rho},\mathbf{k}}(x):\mathbb{R}\to\mathbb{R}^{\breve{\mathbb{c}}}\) of increased order \(\hat{\rho}&gt;\rho\) from the original basis \(\mathbf{b}_{\rho,\mathbf{k}}(x)\). Because the basis of higher order is also a basis for lower order splines, an equivalent higher order spline is determined by interpolation:</p>
<p class="formulaDsp">
\begin{aligned}
s(x)&amp;=\sum_{n=1}^{\breve{{c}}}c_nb_{n,\rho,\mathbf{k}}(x),\\
=s_\mathrm{el}(x)&amp;=\sum_{n=1}^{\breve{{c}}_\mathrm{el}}c_{n,\mathrm{el}}b_{n,\hat{\rho},\mathbf{k}}(x).
\end{aligned}
</p>
<p>Increasing the basis order also introduces additional breakpoints and reduces the distance between the spline and the convex hull <a href="(#2)">[2, IV. B.]</a>.</p>
<div class="image">
<img src="splineOrderElevation.jpg" alt=""/>
<div class="caption">
Spline function and equivalent spline with increased order</div></div>
    <p>The example <em>examples/splineOrderElevation.cpp</em> demonstrates the elevation of a spline of order 3 to order 5. Note that the distance between the coefficients and the spline graph is reduced along the entire spline.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Segment extraction</h2>
<p>The spline in basis form represents a sequence of polynomial segments. The spline is represented in each connected subsequence \(x\in\left[\kappa_{1,\mathrm{se}},\kappa_{\breve{\kappa}_\mathrm{se},\mathrm{se}}\right]\) by another spline \(s_\mathrm{se}(x)=s(x)\) using a subset of the original coefficients \(\{\mathbf{c}_\mathrm{se}\}_{n=1,2,\ldots,\breve{c}_\mathrm{se}}\subset\{\mathbf{c}\}_{n=1,2,\ldots,\breve{c}}\). In the first step, the example <em>examples/splineSegment.cpp</em> demonstrates the extraction of a segment between the breakpoints 0.4 and 0.7 from a spline of order 4. Note that the splines only coincide in the extracted segment.</p>
<div class="image">
<img src="splineSegment.jpg" alt=""/>
<div class="caption">
Segment extraction</div></div>
    <p>The spline representing the extracted segment is not a clamped spline because the first and last coefficients do not coincide with the spline function. However, an equivalent clamped spline \(s_\mathrm{cl}(x)=s_\mathrm{se}(x)\) on the same interval \(x\in\left[\kappa_{1,\mathrm{se}},\kappa_{\breve{\kappa}_\mathrm{se},\mathrm{se}}\right]\) is contained in a tighter convex hull. An equivalent clamped spline is determined by ensuring the equality of the first and last \(\rho\) knots</p>
<p class="formulaDsp">
\begin{aligned}
k_{n,\mathrm{cl}}&amp;=k_{\rho,\mathrm{se}},&amp;&amp;n=1,\ldots,\rho,\\
k_{m,\mathrm{cl}}&amp;=k_{\breve{k}_\mathrm{se}-\rho+1,\mathrm{se}},&amp;&amp;m=\breve{k}_\mathrm{se}-\rho+1,\ldots,\breve{k}_\mathrm{se}-\rho,\\
k_{j,\mathrm{cl}}&amp;=k_{j,\mathrm{se}},&amp;&amp;j=\rho+1,\ldots,\breve{k}_\mathrm{se}-\rho.
\end{aligned}
</p>
<p>In the second step, the example <em>examples/splineSegment.cpp</em> reduces the distance between the spline segment and the convex hull by a clamped segment representation.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
References</h2>
<p><a class="anchor" id="1"></a>[1] C. Boor: <em>A Practical Guide to Splines</em>. 1st ed. Vol. 27. Applied Mathematical Sciences. New York, NY, USA: Springer, Nov. 2001. URL: <a href="https://link.springer.com/book/9780387953663">https://link.springer.com/book/9780387953663</a>.</p>
<p><a class="anchor" id="2"></a>[2] W. van Loock, G. Pipeleers, and J. Swevers: “Optimal motion planning for differentially flat systems with guaranteed constraint satisfaction”. In: <em>2015 American Control Conference (ACC)</em>. July 2015, pp. 4245–4250. DOI: 10.1109/ACC.2015.7171996. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
