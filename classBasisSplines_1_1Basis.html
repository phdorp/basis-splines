<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Basis-splines: BasisSplines::Basis Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Basis-splines
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>BasisSplines</b></li><li class="navelem"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classBasisSplines_1_1Basis-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">BasisSplines::Basis Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classBasisSplines_1_1Basis.html" title="Basis of piecewise polynomial functions represented by truncated powers.">Basis</a> of piecewise polynomial functions represented by truncated powers.  
 <a href="classBasisSplines_1_1Basis.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="basis_8h_source.html">basis.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a04cc4ce7a2e43ea663306749d1c46d55" id="r_a04cc4ce7a2e43ea663306749d1c46d55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a04cc4ce7a2e43ea663306749d1c46d55">Basis</a> (const Eigen::ArrayXd &amp;<a class="el" href="classBasisSplines_1_1Basis.html#a727f938d88fd8b38b107c65df59657bf">knots</a>, int <a class="el" href="classBasisSplines_1_1Basis.html#a487e1e5f78e09ec3bd87aca034ac2c75">order</a>, double scale=1.0)</td></tr>
<tr class="memdesc:a04cc4ce7a2e43ea663306749d1c46d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new basis for the given "knots", "order", and knot "scale".  <br /></td></tr>
<tr class="separator:a04cc4ce7a2e43ea663306749d1c46d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac175dcb212850d9dec63dd8b8df6508d" id="r_ac175dcb212850d9dec63dd8b8df6508d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#ac175dcb212850d9dec63dd8b8df6508d">insertKnots</a> (const Eigen::ArrayXd &amp;knotsIn) const</td></tr>
<tr class="memdesc:ac175dcb212850d9dec63dd8b8df6508d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new basis with knots including "knotsIn" and "this" basis knots.  <br /></td></tr>
<tr class="separator:ac175dcb212850d9dec63dd8b8df6508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff886c6347a619d8c8e6ff9884575fa" id="r_a7ff886c6347a619d8c8e6ff9884575fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a7ff886c6347a619d8c8e6ff9884575fa">combine</a> (const <a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;basis, int <a class="el" href="classBasisSplines_1_1Basis.html#a487e1e5f78e09ec3bd87aca034ac2c75">order</a>, double accScale=1e-6, double accBps=1e-6) const</td></tr>
<tr class="memdesc:a7ff886c6347a619d8c8e6ff9884575fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the knots of "this" and another "basis" to new basis of given "order" [Loo+15]. The "order" cannot subceed maximum of "this" and other "basis" order. * The new basis retains the breakpoints of the source bases.  <br /></td></tr>
<tr class="separator:a7ff886c6347a619d8c8e6ff9884575fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2435753339058c9c7048e18bbbb50d58" id="r_a2435753339058c9c7048e18bbbb50d58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a2435753339058c9c7048e18bbbb50d58">orderDecrease</a> (int change=1) const</td></tr>
<tr class="memdesc:a2435753339058c9c7048e18bbbb50d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine new basis with order decreased by "change".  <br /></td></tr>
<tr class="separator:a2435753339058c9c7048e18bbbb50d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb90fa3773b82f11a6ff5ce6b31010b" id="r_adeb90fa3773b82f11a6ff5ce6b31010b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#adeb90fa3773b82f11a6ff5ce6b31010b">orderIncrease</a> (int change=1) const</td></tr>
<tr class="memdesc:adeb90fa3773b82f11a6ff5ce6b31010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine new basis with order increased by "change". In contrast to <a class="el" href="classBasisSplines_1_1Basis.html#a5daa0b7071ceabde947e74910281a454" title="Determine new basis with order increased by &quot;change&quot;. In constrast to Basis::orderIncrease the breakp...">Basis::orderElevation</a> the knot multiplicity is preserved except for the first and last knots.  <br /></td></tr>
<tr class="separator:adeb90fa3773b82f11a6ff5ce6b31010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daa0b7071ceabde947e74910281a454" id="r_a5daa0b7071ceabde947e74910281a454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a5daa0b7071ceabde947e74910281a454">orderElevation</a> (int change=1) const</td></tr>
<tr class="memdesc:a5daa0b7071ceabde947e74910281a454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine new basis with order increased by "change". In constrast to <a class="el" href="classBasisSplines_1_1Basis.html#adeb90fa3773b82f11a6ff5ce6b31010b" title="Determine new basis with order increased by &quot;change&quot;. In contrast to Basis::orderElevation the knot m...">Basis::orderIncrease</a> the breakpoint continuity is preserved.  <br /></td></tr>
<tr class="separator:a5daa0b7071ceabde947e74910281a454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c857c66a0bc169041e94413ed9b5cd" id="r_a48c857c66a0bc169041e94413ed9b5cd"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a48c857c66a0bc169041e94413ed9b5cd">derivative</a> (<a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;basis, int orderDer=1) const</td></tr>
<tr class="memdesc:a48c857c66a0bc169041e94413ed9b5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dertermines a matrix A to transform the spline coefficients c to derivative coefficients dc.  <br /></td></tr>
<tr class="separator:a48c857c66a0bc169041e94413ed9b5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fa50adb30f017cd54e256628ad6f6c" id="r_ab6fa50adb30f017cd54e256628ad6f6c"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#ab6fa50adb30f017cd54e256628ad6f6c">derivative</a> (<a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;basis, const Eigen::MatrixXd &amp;values, int orderDer=1) const</td></tr>
<tr class="memdesc:ab6fa50adb30f017cd54e256628ad6f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given values, which are basis spline values or coefficients, to the derivative of this basis.  <br /></td></tr>
<tr class="separator:ab6fa50adb30f017cd54e256628ad6f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f71ffebafbb60b3863bda90afb635b" id="r_ad6f71ffebafbb60b3863bda90afb635b"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#ad6f71ffebafbb60b3863bda90afb635b">integral</a> (<a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;basis, int orderInt=1) const</td></tr>
<tr class="memdesc:ad6f71ffebafbb60b3863bda90afb635b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dertermines a matrix A to transform the spline coefficients c to integral coefficients ic.  <br /></td></tr>
<tr class="separator:ad6f71ffebafbb60b3863bda90afb635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188dcfe54881ee245db9da352af2336d" id="r_a188dcfe54881ee245db9da352af2336d"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a188dcfe54881ee245db9da352af2336d">integral</a> (<a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;basis, const Eigen::MatrixXd &amp;values, int orderInt=1) const</td></tr>
<tr class="memdesc:a188dcfe54881ee245db9da352af2336d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given values, which are basis spline values or coefficients, to the integral of this basis.  <br /></td></tr>
<tr class="separator:a188dcfe54881ee245db9da352af2336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e8aff0a48234ff2ec75d527eaa4196" id="r_a28e8aff0a48234ff2ec75d527eaa4196"><td class="memTemplParams" colspan="2">template&lt;typename Interp  = Interpolate&gt; </td></tr>
<tr class="memitem:a28e8aff0a48234ff2ec75d527eaa4196"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a28e8aff0a48234ff2ec75d527eaa4196">add</a> (const <a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;basis, <a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;basisOut) const</td></tr>
<tr class="memdesc:a28e8aff0a48234ff2ec75d527eaa4196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine transformation matrices Tl and Tr for left and right operand coefficients cl and cr to get sum coefficients cs.  <br /></td></tr>
<tr class="separator:a28e8aff0a48234ff2ec75d527eaa4196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dbb7291bc143645fba359a3f1da8f9" id="r_a66dbb7291bc143645fba359a3f1da8f9"><td class="memTemplParams" colspan="2">template&lt;typename Interp  = Interpolate&gt; </td></tr>
<tr class="memitem:a66dbb7291bc143645fba359a3f1da8f9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a66dbb7291bc143645fba359a3f1da8f9">prod</a> (const <a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;basis, <a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;basisOut) const</td></tr>
<tr class="memdesc:a66dbb7291bc143645fba359a3f1da8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine transformation matrixT for coefficients cl and cr to get product coefficients cs.  <br /></td></tr>
<tr class="separator:a66dbb7291bc143645fba359a3f1da8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f2ec9c73c28e8caeb853b23fdb40b4" id="r_a74f2ec9c73c28e8caeb853b23fdb40b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a74f2ec9c73c28e8caeb853b23fdb40b4">dim</a> () const</td></tr>
<tr class="memdesc:a74f2ec9c73c28e8caeb853b23fdb40b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine basis dimensionality.  <br /></td></tr>
<tr class="separator:a74f2ec9c73c28e8caeb853b23fdb40b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487e1e5f78e09ec3bd87aca034ac2c75" id="r_a487e1e5f78e09ec3bd87aca034ac2c75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a487e1e5f78e09ec3bd87aca034ac2c75">order</a> () const</td></tr>
<tr class="memdesc:a487e1e5f78e09ec3bd87aca034ac2c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine basis order.  <br /></td></tr>
<tr class="separator:a487e1e5f78e09ec3bd87aca034ac2c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727f938d88fd8b38b107c65df59657bf" id="r_a727f938d88fd8b38b107c65df59657bf"><td class="memItemLeft" align="right" valign="top">const Eigen::ArrayXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a727f938d88fd8b38b107c65df59657bf">knots</a> () const</td></tr>
<tr class="memdesc:a727f938d88fd8b38b107c65df59657bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine basis knots.  <br /></td></tr>
<tr class="separator:a727f938d88fd8b38b107c65df59657bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c8249d65326c28cadde39a24b376d4" id="r_ab0c8249d65326c28cadde39a24b376d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#ab0c8249d65326c28cadde39a24b376d4">setBreakpoints</a> (const Eigen::ArrayXd &amp;breakpointsNew, const Eigen::ArrayXi &amp;idcs)</td></tr>
<tr class="memdesc:ab0c8249d65326c28cadde39a24b376d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set breakpoints at given breakpoint indices.  <br /></td></tr>
<tr class="separator:ab0c8249d65326c28cadde39a24b376d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55678bb833c16106d0dbee9cb34ace1d" id="r_a55678bb833c16106d0dbee9cb34ace1d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::ArrayXd, Eigen::ArrayXi &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a55678bb833c16106d0dbee9cb34ace1d">getBreakpoints</a> (double accuracy=1e-6) const</td></tr>
<tr class="memdesc:a55678bb833c16106d0dbee9cb34ace1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine basis breakpoints and continuities at breakpoints.  <br /></td></tr>
<tr class="separator:a55678bb833c16106d0dbee9cb34ace1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85aa6a534a079b400aa7734934dd6b0" id="r_ad85aa6a534a079b400aa7734934dd6b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#ad85aa6a534a079b400aa7734934dd6b0">getScale</a> () const</td></tr>
<tr class="memdesc:ad85aa6a534a079b400aa7734934dd6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basis scaling factor.  <br /></td></tr>
<tr class="separator:ad85aa6a534a079b400aa7734934dd6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3779b38163f3ec75f3408922e99635c" id="r_af3779b38163f3ec75f3408922e99635c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#af3779b38163f3ec75f3408922e99635c">setScale</a> (double scale)</td></tr>
<tr class="memdesc:af3779b38163f3ec75f3408922e99635c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the basis scaling factor.  <br /></td></tr>
<tr class="separator:af3779b38163f3ec75f3408922e99635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0168e0a0b4968703c950c113c6c20804" id="r_a0168e0a0b4968703c950c113c6c20804"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a0168e0a0b4968703c950c113c6c20804">operator()</a> (const Eigen::ArrayXd &amp;points, double accBps=1e-6, double accSegment=1e-6) const</td></tr>
<tr class="memdesc:a0168e0a0b4968703c950c113c6c20804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the truncated power basis at the given "points". The basis values are computed iteratively using lower order evaluations [Boo01, B-spline prop. (i)] for each point.  <br /></td></tr>
<tr class="separator:a0168e0a0b4968703c950c113c6c20804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c52be56770c67210cca2cec4073cd27" id="r_a5c52be56770c67210cca2cec4073cd27"><td class="memItemLeft" align="right" valign="top">Eigen::ArrayXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a5c52be56770c67210cca2cec4073cd27">greville</a> () const</td></tr>
<tr class="memdesc:a5c52be56770c67210cca2cec4073cd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the Greville sites representing the knot averages [Boo01, prop. (v)].  <br /></td></tr>
<tr class="separator:a5c52be56770c67210cca2cec4073cd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211c2bf9e7de742aaa21ae952ee6602a" id="r_a211c2bf9e7de742aaa21ae952ee6602a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a211c2bf9e7de742aaa21ae952ee6602a">getSegment</a> (int first, int last) const</td></tr>
<tr class="memdesc:a211c2bf9e7de742aaa21ae952ee6602a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a basis representing the "first" to the "last" segment of "this" basis.  <br /></td></tr>
<tr class="separator:a211c2bf9e7de742aaa21ae952ee6602a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e16e7704052fa3be1b301e49ad8be6" id="r_a40e16e7704052fa3be1b301e49ad8be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a40e16e7704052fa3be1b301e49ad8be6">getSegment</a> (Eigen::internal::pointer_based_stl_iterator&lt; const Eigen::ArrayXd &gt; begin, Eigen::internal::pointer_based_stl_iterator&lt; const Eigen::ArrayXd &gt; end) const</td></tr>
<tr class="memdesc:a40e16e7704052fa3be1b301e49ad8be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a basis representing the segment marked by "begin" and "end" of this basis knots.  <br /></td></tr>
<tr class="separator:a40e16e7704052fa3be1b301e49ad8be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1fa27e5ff0da223e2e9b4fe78e0e2a" id="r_a8c1fa27e5ff0da223e2e9b4fe78e0e2a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::internal::pointer_based_stl_iterator&lt; const Eigen::ArrayXd &gt;, Eigen::internal::pointer_based_stl_iterator&lt; const Eigen::ArrayXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a8c1fa27e5ff0da223e2e9b4fe78e0e2a">getSegmentKnots</a> (int first, int last) const</td></tr>
<tr class="memdesc:a8c1fa27e5ff0da223e2e9b4fe78e0e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine iterators pointing to the begin and end of knots corresponding to the "first" to the "last" segment of "this" basis.  <br /></td></tr>
<tr class="separator:a8c1fa27e5ff0da223e2e9b4fe78e0e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42d2ef94478eeb389e3b116cd49916f" id="r_aa42d2ef94478eeb389e3b116cd49916f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#aa42d2ef94478eeb389e3b116cd49916f">getClamped</a> () const</td></tr>
<tr class="memdesc:aa42d2ef94478eeb389e3b116cd49916f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine basis with knots clamped to basis segment.  <br /></td></tr>
<tr class="separator:aa42d2ef94478eeb389e3b116cd49916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa3ccaa04afe788dbd6a2a55b9186dc2d" id="r_aa3ccaa04afe788dbd6a2a55b9186dc2d"><td class="memItemLeft" align="right" valign="top">static Eigen::ArrayXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#aa3ccaa04afe788dbd6a2a55b9186dc2d">toKnots</a> (const Eigen::ArrayXd &amp;breakpoints, const Eigen::ArrayXi &amp;continuities, int <a class="el" href="classBasisSplines_1_1Basis.html#a487e1e5f78e09ec3bd87aca034ac2c75">order</a>)</td></tr>
<tr class="memdesc:aa3ccaa04afe788dbd6a2a55b9186dc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map "breakpoints" and "continuities" to knots [Boo01, th. (44)].  <br /></td></tr>
<tr class="separator:aa3ccaa04afe788dbd6a2a55b9186dc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e1115109be8a6f8805ba9b4adb4ddf" id="r_a42e1115109be8a6f8805ba9b4adb4ddf"><td class="memItemLeft" align="right" valign="top">static Eigen::ArrayXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a42e1115109be8a6f8805ba9b4adb4ddf">toKnots</a> (const std::pair&lt; Eigen::ArrayXd, Eigen::ArrayXi &gt; &amp;breakpoints, int <a class="el" href="classBasisSplines_1_1Basis.html#a487e1e5f78e09ec3bd87aca034ac2c75">order</a>)</td></tr>
<tr class="memdesc:a42e1115109be8a6f8805ba9b4adb4ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a pair of breakpoints and continuities to knots [Boo01, th. (44)].  <br /></td></tr>
<tr class="separator:a42e1115109be8a6f8805ba9b4adb4ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eba517d75461086381b8df9ddb39f4" id="r_a89eba517d75461086381b8df9ddb39f4"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; Eigen::ArrayXd, Eigen::ArrayXi &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasisSplines_1_1Basis.html#a89eba517d75461086381b8df9ddb39f4">toBreakpoints</a> (const Eigen::ArrayXd &amp;<a class="el" href="classBasisSplines_1_1Basis.html#a727f938d88fd8b38b107c65df59657bf">knots</a>, int <a class="el" href="classBasisSplines_1_1Basis.html#a487e1e5f78e09ec3bd87aca034ac2c75">order</a>, double accuracy=1e-6)</td></tr>
<tr class="memdesc:a89eba517d75461086381b8df9ddb39f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map "knots" to breakpoints and their order of continuity [Boo01, th. (44)]. Map all knots in [breakpoint, breakpoint + "accuracy"] to the same breakpoint.  <br /></td></tr>
<tr class="separator:a89eba517d75461086381b8df9ddb39f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classBasisSplines_1_1Basis.html" title="Basis of piecewise polynomial functions represented by truncated powers.">Basis</a> of piecewise polynomial functions represented by truncated powers. </p>
<p>The basis is defined by its order and an increasing sequence of knots. It provides properties that are derived from the knots and degree. Allows the combination of two splines bases. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a04cc4ce7a2e43ea663306749d1c46d55" name="a04cc4ce7a2e43ea663306749d1c46d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cc4ce7a2e43ea663306749d1c46d55">&#9670;&#160;</a></span>Basis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BasisSplines::Basis::Basis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new basis for the given "knots", "order", and knot "scale". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knots</td><td>knot locations. </td></tr>
    <tr><td class="paramname">order</td><td>basis order. </td></tr>
    <tr><td class="paramname">scale</td><td>knot scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a28e8aff0a48234ff2ec75d527eaa4196" name="a28e8aff0a48234ff2ec75d527eaa4196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e8aff0a48234ff2ec75d527eaa4196">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interp  = Interpolate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt; BasisSplines::Basis::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basisOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine transformation matrices Tl and Tr for left and right operand coefficients cl and cr to get sum coefficients cs. </p>
<p>cs = Tl * cl + Tr * cr</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>right operand basis. </td></tr>
    <tr><td class="paramname">basisOut</td><td>sum basis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;Eigen::MatrixXd, Eigen::MatrixXd&gt; transformation matrices Tl and Tr. </dd></dl>

</div>
</div>
<a id="a7ff886c6347a619d8c8e6ff9884575fa" name="a7ff886c6347a619d8c8e6ff9884575fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff886c6347a619d8c8e6ff9884575fa">&#9670;&#160;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> BasisSplines::Basis::combine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accScale</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accBps</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine the knots of "this" and another "basis" to new basis of given "order" [Loo+15]. The "order" cannot subceed maximum of "this" and other "basis" order. * The new basis retains the breakpoints of the source bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>other basis to combine with. </td></tr>
    <tr><td class="paramname">order</td><td>result basis order. </td></tr>
    <tr><td class="paramname">accScale</td><td>accepted difference between "this" and other "basis" scaling. </td></tr>
    <tr><td class="paramname">accBps</td><td>tolerance for assigning knots to breakpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::ArrayXd knots as the combination of both bases. </dd></dl>

</div>
</div>
<a id="ab6fa50adb30f017cd54e256628ad6f6c" name="ab6fa50adb30f017cd54e256628ad6f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fa50adb30f017cd54e256628ad6f6c">&#9670;&#160;</a></span>derivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd BasisSplines::Basis::derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orderDer</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the given values, which are basis spline values or coefficients, to the derivative of this basis. </p>
<p>[Boo01, B-spline prop. (viii)]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>basis of reduced order. </td></tr>
    <tr><td class="paramname">values</td><td>basis values or spline coefficients. </td></tr>
    <tr><td class="paramname">orderDer</td><td>derivative order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::MatrixXd derivative values. </dd></dl>

</div>
</div>
<a id="a48c857c66a0bc169041e94413ed9b5cd" name="a48c857c66a0bc169041e94413ed9b5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c857c66a0bc169041e94413ed9b5cd">&#9670;&#160;</a></span>derivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd BasisSplines::Basis::derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orderDer</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dertermines a matrix A to transform the spline coefficients c to derivative coefficients dc. </p>
<p>dc = A * c</p>
<p>[Boo01, B-spline prop. (viii)]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>basis of reduced order. </td></tr>
    <tr><td class="paramname">orderDer</td><td>derivative order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::MatrixXd transformation matrix. </dd></dl>

</div>
</div>
<a id="a74f2ec9c73c28e8caeb853b23fdb40b4" name="a74f2ec9c73c28e8caeb853b23fdb40b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f2ec9c73c28e8caeb853b23fdb40b4">&#9670;&#160;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BasisSplines::Basis::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine basis dimensionality. </p>
<dl class="section return"><dt>Returns</dt><dd>int basis dimensionality. </dd></dl>

</div>
</div>
<a id="a55678bb833c16106d0dbee9cb34ace1d" name="a55678bb833c16106d0dbee9cb34ace1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55678bb833c16106d0dbee9cb34ace1d">&#9670;&#160;</a></span>getBreakpoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::ArrayXd, Eigen::ArrayXi &gt; BasisSplines::Basis::getBreakpoints </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-6</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine basis breakpoints and continuities at breakpoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accuracy</td><td>tolerance for assigning knots to breakpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;Eigen::ArrayXd, Eigen::ArrayXi&gt; breakpoints and continuities. </dd></dl>

</div>
</div>
<a id="aa42d2ef94478eeb389e3b116cd49916f" name="aa42d2ef94478eeb389e3b116cd49916f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42d2ef94478eeb389e3b116cd49916f">&#9670;&#160;</a></span>getClamped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> BasisSplines::Basis::getClamped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine basis with knots clamped to basis segment. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classBasisSplines_1_1Basis.html" title="Basis of piecewise polynomial functions represented by truncated powers.">Basis</a> clamped basis. </dd></dl>

</div>
</div>
<a id="ad85aa6a534a079b400aa7734934dd6b0" name="ad85aa6a534a079b400aa7734934dd6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85aa6a534a079b400aa7734934dd6b0">&#9670;&#160;</a></span>getScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BasisSplines::Basis::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the basis scaling factor. </p>
<dl class="section return"><dt>Returns</dt><dd>double scaling fator. </dd></dl>

</div>
</div>
<a id="a40e16e7704052fa3be1b301e49ad8be6" name="a40e16e7704052fa3be1b301e49ad8be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e16e7704052fa3be1b301e49ad8be6">&#9670;&#160;</a></span>getSegment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> BasisSplines::Basis::getSegment </td>
          <td>(</td>
          <td class="paramtype">Eigen::internal::pointer_based_stl_iterator&lt; const Eigen::ArrayXd &gt;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::internal::pointer_based_stl_iterator&lt; const Eigen::ArrayXd &gt;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine a basis representing the segment marked by "begin" and "end" of this basis knots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first knot of a segment. </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing to the last knot of a segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classBasisSplines_1_1Basis.html" title="Basis of piecewise polynomial functions represented by truncated powers.">Basis</a> segment basis. </dd></dl>

</div>
</div>
<a id="a211c2bf9e7de742aaa21ae952ee6602a" name="a211c2bf9e7de742aaa21ae952ee6602a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211c2bf9e7de742aaa21ae952ee6602a">&#9670;&#160;</a></span>getSegment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> BasisSplines::Basis::getSegment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine a basis representing the "first" to the "last" segment of "this" basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>index of the first segment. </td></tr>
    <tr><td class="paramname">last</td><td>index of the last segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classBasisSplines_1_1Basis.html" title="Basis of piecewise polynomial functions represented by truncated powers.">Basis</a> segment basis. </dd></dl>

</div>
</div>
<a id="a8c1fa27e5ff0da223e2e9b4fe78e0e2a" name="a8c1fa27e5ff0da223e2e9b4fe78e0e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1fa27e5ff0da223e2e9b4fe78e0e2a">&#9670;&#160;</a></span>getSegmentKnots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::internal::pointer_based_stl_iterator&lt; const Eigen::ArrayXd &gt;, Eigen::internal::pointer_based_stl_iterator&lt; const Eigen::ArrayXd &gt; &gt; BasisSplines::Basis::getSegmentKnots </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine iterators pointing to the begin and end of knots corresponding to the "first" to the "last" segment of "this" basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>index of the first segment. </td></tr>
    <tr><td class="paramname">last</td><td>index of the last segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;Eigen::internal::pointer_based_stl_iterator&lt;const
Eigen::ArrayXd&gt;, Eigen::internal::pointer_based_stl_iterator&lt;const
Eigen::ArrayXd&gt;&gt; Iterators pointing to the begin and end of a knot sequence. </dd></dl>

</div>
</div>
<a id="a5c52be56770c67210cca2cec4073cd27" name="a5c52be56770c67210cca2cec4073cd27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c52be56770c67210cca2cec4073cd27">&#9670;&#160;</a></span>greville()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::ArrayXd BasisSplines::Basis::greville </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the Greville sites representing the knot averages [Boo01, prop. (v)]. </p>
<dl class="section return"><dt>Returns</dt><dd>Eigen::ArrayXd greville sites. </dd></dl>

</div>
</div>
<a id="ac175dcb212850d9dec63dd8b8df6508d" name="ac175dcb212850d9dec63dd8b8df6508d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac175dcb212850d9dec63dd8b8df6508d">&#9670;&#160;</a></span>insertKnots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> BasisSplines::Basis::insertKnots </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>knotsIn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new basis with knots including "knotsIn" and "this" basis knots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knotsIn</td><td>knots to insert to this basis' knots. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classBasisSplines_1_1Basis.html" title="Basis of piecewise polynomial functions represented by truncated powers.">Basis</a> new basis including the given knots. </dd></dl>

</div>
</div>
<a id="a188dcfe54881ee245db9da352af2336d" name="a188dcfe54881ee245db9da352af2336d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188dcfe54881ee245db9da352af2336d">&#9670;&#160;</a></span>integral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd BasisSplines::Basis::integral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orderInt</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the given values, which are basis spline values or coefficients, to the integral of this basis. </p>
<p>[Boo01, eq. (31)]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>basis of increased order. </td></tr>
    <tr><td class="paramname">values</td><td>basis values or spline coefficients. </td></tr>
    <tr><td class="paramname">orderInt</td><td>integral order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::VectorXd integral values. </dd></dl>

</div>
</div>
<a id="ad6f71ffebafbb60b3863bda90afb635b" name="ad6f71ffebafbb60b3863bda90afb635b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f71ffebafbb60b3863bda90afb635b">&#9670;&#160;</a></span>integral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd BasisSplines::Basis::integral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orderInt</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dertermines a matrix A to transform the spline coefficients c to integral coefficients ic. </p>
<p>ic = A * c</p>
<p>[Boo01, eq. (31)]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>basis spline. </td></tr>
    <tr><td class="paramname">orderInt</td><td>integral order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::MatrixXd transformation matrix. </dd></dl>

</div>
</div>
<a id="a727f938d88fd8b38b107c65df59657bf" name="a727f938d88fd8b38b107c65df59657bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727f938d88fd8b38b107c65df59657bf">&#9670;&#160;</a></span>knots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::ArrayXd &amp; BasisSplines::Basis::knots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine basis knots. </p>
<dl class="section return"><dt>Returns</dt><dd>const Eigen::ArrayXd&amp; basis knots. </dd></dl>

</div>
</div>
<a id="a0168e0a0b4968703c950c113c6c20804" name="a0168e0a0b4968703c950c113c6c20804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0168e0a0b4968703c950c113c6c20804">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd BasisSplines::Basis::operator() </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accBps</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accSegment</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the truncated power basis at the given "points". The basis values are computed iteratively using lower order evaluations [Boo01, B-spline prop. (i)] for each point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>evaluation points. </td></tr>
    <tr><td class="paramname">accBps</td><td>minimum distance between breakpoints. </td></tr>
    <tr><td class="paramname">accSegment</td><td>accuracy point assignment to knot segment for order 1 basis values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::ArrayXd values of truncated powers with "points.size()" rows and "self-&gt;dim()" columns. </dd></dl>

</div>
</div>
<a id="a487e1e5f78e09ec3bd87aca034ac2c75" name="a487e1e5f78e09ec3bd87aca034ac2c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487e1e5f78e09ec3bd87aca034ac2c75">&#9670;&#160;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BasisSplines::Basis::order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine basis order. </p>
<dl class="section return"><dt>Returns</dt><dd>int basis order. </dd></dl>

</div>
</div>
<a id="a2435753339058c9c7048e18bbbb50d58" name="a2435753339058c9c7048e18bbbb50d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2435753339058c9c7048e18bbbb50d58">&#9670;&#160;</a></span>orderDecrease()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> BasisSplines::Basis::orderDecrease </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>change</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine new basis with order decreased by "change". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">change</td><td>order to decrease. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classBasisSplines_1_1Basis.html" title="Basis of piecewise polynomial functions represented by truncated powers.">Basis</a> basis with reduced order. </dd></dl>

</div>
</div>
<a id="a5daa0b7071ceabde947e74910281a454" name="a5daa0b7071ceabde947e74910281a454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5daa0b7071ceabde947e74910281a454">&#9670;&#160;</a></span>orderElevation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> BasisSplines::Basis::orderElevation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>change</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine new basis with order increased by "change". In constrast to <a class="el" href="classBasisSplines_1_1Basis.html#adeb90fa3773b82f11a6ff5ce6b31010b" title="Determine new basis with order increased by &quot;change&quot;. In contrast to Basis::orderElevation the knot m...">Basis::orderIncrease</a> the breakpoint continuity is preserved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">change</td><td>order to increase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classBasisSplines_1_1Basis.html" title="Basis of piecewise polynomial functions represented by truncated powers.">Basis</a> basis with increased order. </dd></dl>

</div>
</div>
<a id="adeb90fa3773b82f11a6ff5ce6b31010b" name="adeb90fa3773b82f11a6ff5ce6b31010b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb90fa3773b82f11a6ff5ce6b31010b">&#9670;&#160;</a></span>orderIncrease()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> BasisSplines::Basis::orderIncrease </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>change</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine new basis with order increased by "change". In contrast to <a class="el" href="classBasisSplines_1_1Basis.html#a5daa0b7071ceabde947e74910281a454" title="Determine new basis with order increased by &quot;change&quot;. In constrast to Basis::orderIncrease the breakp...">Basis::orderElevation</a> the knot multiplicity is preserved except for the first and last knots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">change</td><td>order to increase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classBasisSplines_1_1Basis.html" title="Basis of piecewise polynomial functions represented by truncated powers.">Basis</a> basis with increased order. </dd></dl>

</div>
</div>
<a id="a66dbb7291bc143645fba359a3f1da8f9" name="a66dbb7291bc143645fba359a3f1da8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66dbb7291bc143645fba359a3f1da8f9">&#9670;&#160;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interp  = Interpolate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd BasisSplines::Basis::prod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasisSplines_1_1Basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basisOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine transformation matrixT for coefficients cl and cr to get product coefficients cs. </p>
<p>cs = T (cl \kron cr)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>right operand basis. </td></tr>
    <tr><td class="paramname">basisOut</td><td>product basis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::MatrixXd transformation matrix T. </dd></dl>

</div>
</div>
<a id="ab0c8249d65326c28cadde39a24b376d4" name="ab0c8249d65326c28cadde39a24b376d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c8249d65326c28cadde39a24b376d4">&#9670;&#160;</a></span>setBreakpoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BasisSplines::Basis::setBreakpoints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>breakpointsNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>idcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set breakpoints at given breakpoint indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">breakpointsNew</td><td>new breakpoints. </td></tr>
    <tr><td class="paramname">idcs</td><td>breakpoint indices to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3779b38163f3ec75f3408922e99635c" name="af3779b38163f3ec75f3408922e99635c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3779b38163f3ec75f3408922e99635c">&#9670;&#160;</a></span>setScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BasisSplines::Basis::setScale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the basis scaling factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scaling fator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89eba517d75461086381b8df9ddb39f4" name="a89eba517d75461086381b8df9ddb39f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89eba517d75461086381b8df9ddb39f4">&#9670;&#160;</a></span>toBreakpoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt; Eigen::ArrayXd, Eigen::ArrayXi &gt; BasisSplines::Basis::toBreakpoints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map "knots" to breakpoints and their order of continuity [Boo01, th. (44)]. Map all knots in [breakpoint, breakpoint + "accuracy"] to the same breakpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knots</td><td>query points mapped to breakpoints. </td></tr>
    <tr><td class="paramname">order</td><td>basis order. </td></tr>
    <tr><td class="paramname">accuracy</td><td>tolerance for assigning knots to breakpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;Eigen::ArrayXd, Eigen::ArrayXi&gt; breakpoints and their continuities. </dd></dl>

</div>
</div>
<a id="aa3ccaa04afe788dbd6a2a55b9186dc2d" name="aa3ccaa04afe788dbd6a2a55b9186dc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ccaa04afe788dbd6a2a55b9186dc2d">&#9670;&#160;</a></span>toKnots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::ArrayXd BasisSplines::Basis::toKnots </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>breakpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>continuities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map "breakpoints" and "continuities" to knots [Boo01, th. (44)]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">breakpoints</td><td>breakpoints mapped to knots. </td></tr>
    <tr><td class="paramname">continuities</td><td>breakpoint continuities. </td></tr>
    <tr><td class="paramname">order</td><td>basis order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::ArrayXd knot representation of given breakpoints. </dd></dl>

</div>
</div>
<a id="a42e1115109be8a6f8805ba9b4adb4ddf" name="a42e1115109be8a6f8805ba9b4adb4ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e1115109be8a6f8805ba9b4adb4ddf">&#9670;&#160;</a></span>toKnots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::ArrayXd BasisSplines::Basis::toKnots </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; Eigen::ArrayXd, Eigen::ArrayXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>breakpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map a pair of breakpoints and continuities to knots [Boo01, th. (44)]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">breakpoints</td><td>pair of breakpoints and continuties </td></tr>
    <tr><td class="paramname">order</td><td>basis order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::ArrayXd </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/basis-splines/basis-splines/include/basisSplines/<a class="el" href="basis_8h_source.html">basis.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
